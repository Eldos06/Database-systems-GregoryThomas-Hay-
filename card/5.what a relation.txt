✳️ **5. Explain what a relation is and cite the conditions that make one.** | In relational database theory, a *relation* is a logical representation of data stored in a two-dimensional table composed of rows and columns. Each row (tuplе) represents a single record and each column represents an attribute of that record. A relation has these main conditions: 1. All cells contain atomic (single) values — no lists or arrays inside a field. 2. Each record is unique — identified by a primary key. 3. Columns have distinct names and consistent data types. 4. The order of rows and columns does not affect meaning. When these rules are followed, the table is a true relation, allowing SQL operations like JOIN, SELECT, and GROUP BY to work predictably and mathematically. Relations are the foundation of normalization and referential integrity in modern databases. 	 ✳️ **5. Объясните, что такое отношение и назовите условия, делающие его таковым.** | В реляционной теории баз данных *отношение* — это логическое представление данных в виде двумерной таблицы, состоящей из строк и столбцов. Каждая строка (кортеж) описывает одну запись, а каждый столбец — атрибут этой записи. Главные условия: 1. Все ячейки содержат атомарные (единичные) значения — никаких списков или множеств. 2. Каждая запись уникальна — идентифицируется первичным ключом. 3. Столбцы имеют разные имена и строгие типы данных. 4. Порядок строк и столбцов не влияет на смысл. Если эти правила соблюдены, таблица является настоящим отношением и может использовать операции SQL (JOIN, SELECT, GROUP BY) предсказуемо и строго по математическим законам. Отношения лежат в основе нормализации и ссылочной целостности современных баз данных.

**a. Describe what is meant by “domain” and provide an example.** | A domain is the set of all possible values that a column (attribute) can contain. It defines data type, format, and constraints for that field. For example, the domain of a column `BirthDate` is all valid calendar dates within a reasonable range (e.g., 1900-01-01 to current date). The domain of `Salary` might be numeric values greater than zero. Domains protect data quality and prevent nonsensical values like text in a numeric field or future dates in birthdays. They are the first layer of data validation in the relational model. 	 **a. Опишите, что такое домен, и приведите пример.** | Домен — это множество всех допустимых значений, которые может принимать столбец (атрибут). Он определяет тип данных, формат и ограничения для поля. Например, домен столбца `BirthDate` — все корректные даты календаря в разумных пределах (например, 1900-01-01 до текущей даты). Домен `Salary` может включать только числовые значения больше нуля. Домены защищают качество данных и предотвращают ошибки, такие как текст в числовом поле или будущие даты в днях рождения. Это первый уровень валидации данных в реляционной модели.

**b. Explain what a constraint is and provide an example.** | Constraints are rules applied to columns or tables to maintain data accuracy and integrity. Common constraints include PRIMARY KEY (uniqueness and non-null), FOREIGN KEY (referential link), UNIQUE, CHECK, and NOT NULL. For example, a CHECK constraint on `Age > 18` prevents inserting minors into an adult table. Constraints ensure data follows business logic and eliminate invalid entries before they reach the database. 	 **b. Объясните, что такое ограничение, и приведите пример.** | Ограничения — это правила, применяемые к столбцам или таблицам для сохранения точности и целостности данных. Основные типы: PRIMARY KEY (уникальность и непустое значение), FOREIGN KEY (ссылочная связь), UNIQUE, CHECK и NOT NULL. Например, ограничение CHECK для `Age > 18` не позволит вставить несовершеннолетнего в таблицу взрослых. Ограничения гарантируют соблюдение бизнес-логики и предотвращают ошибочные вводы до попадания в базу данных.

**c. Explain differences between composite, multi-valued, and derived attributes and provide examples of each.** | 1. Composite attributes can be split into smaller parts. Example: `FullName` → `FirstName`, `LastName`. 2. Multi-valued attributes contain more than one value for a single entity. Example: a customer can have several phone numbers. These must be stored in a separate table for normalization. 3. Derived attributes are calculated from other attributes. Example: `Age` derived from `BirthDate`. Understanding these differences prevents duplication and improves efficiency of the data model. 	 **c. Объясните разницу между составными, многозначными и производными атрибутами и приведите пример каждого.** | 1. Составные атрибуты можно разделить на части. Пример: `FullName` → `FirstName`, `LastName`. 2. Многозначные атрибуты содержат несколько значений для одной сущности. Пример: у клиента может быть несколько телефонов; их следует хранить в отдельной таблице для нормализации. 3. Производные атрибуты вычисляются из других атрибутов. Пример: `Age` рассчитывается по `BirthDate`. Понимание разницы помогает избежать дублирования и повысить эффективность модели данных.

**d. Explain decisions designers make when establishing each primary key; what is the preferred data type and configuration settings? Why?** | Database designers select primary keys based on stability, uniqueness, and simplicity. Preferred type is an integer (auto-incrementing) called a surrogate key. Reasons: 1. It is short and indexable, improving join speed. 2. It never changes, so referential integrity remains intact. 3. It is meaningless to users, so business logic can change without affecting keys. Configurations usually include `IDENTITY(1,1)` or `AUTO_INCREMENT` and NOT NULL with PRIMARY KEY constraint. Natural keys (like email or ID number) can be used when stable and unambiguous but often risk update anomalies. Thus, surrogate numeric keys are industry standard. 	 **d. Объясните, какие решения принимают проектировщики при определении первичного ключа; какой тип данных и настройки предпочтительны и почему.** | Проектировщики БД выбирают первичные ключи по критериям стабильности, уникальности и простоты. Предпочтительный тип — целое число (автоинкремент), называемое суррогатным ключом. Причины: 1. Короткий и индексируемый, ускоряет соединения. 2. Никогда не меняется, поэтому сохраняется ссылочная целостность. 3. Не имеет делового смысла, и логика может меняться без влияния на ключи. Обычно используются настройки `IDENTITY(1,1)` или `AUTO_INCREMENT`, а также NOT NULL с PRIMARY KEY. Естественные ключи (например, email или номер удостоверения) применяются, если они стабильны и однозначны, но могут создавать аномалии обновлений. Поэтому суррогатные числовые ключи являются отраслевым стандартом.

